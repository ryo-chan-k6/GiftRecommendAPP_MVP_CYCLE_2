# S3 Raw 保存仕様（MVP）

## 0. 目的

楽天APIレスポンスを immutable（削除しない）に保存し、後から以下ができる状態を作る。

- 再処理（リプレイ）
- 差分解析
- バグ調査（「当時の事実」確認）

DBは「最新参照・正規化結果」を持ち、履歴は S3が正とする。

## 1. バケット設計（環境分離）

### 1.1 バケット名（確定）

- giftrecommend-raw-dev
- giftrecommend-raw-prod

### 1.2 分離の理由（事実）

devの検証データがprodに混ざると、復元・解析・課金・権限管理が崩れるため。

## 2. 保存対象（entity別）

| entity | 取得元 | 代表source_id | 保存目的 |
| --- | --- | --- | --- |
| ranking | Rakuten Ranking API | genreId | ランキング結果の事実保管 |
| item | Rakuten Item API | itemCode | 商品詳細の事実保管（タグ/ジャンル/ショップ含む） |
| genre | Rakuten Genre API | genreId | ジャンル定義の事実保管 |
| tag | Rakuten Tag API | tagId | タグ定義（group含む）の事実保管 |

## 3. S3 key設計（確定：案A）

### 3.1 基本形

`raw/source=rakuten/entity=<entity>/source_id=<sourceId>/hash=<contentHash>.json`

### 3.2 entity別の具体例

**item**

`raw/source=rakuten/entity=item/source_id=<itemCode>/hash=<contentHash>.json`

**genre**

`raw/source=rakuten/entity=genre/source_id=<genreId>/hash=<contentHash>.json`

**tag**

`raw/source=rakuten/entity=tag/source_id=<tagId>/hash=<contentHash>.json`

**ranking**

`raw/source=rakuten/entity=ranking/source_id=<genreId>/hash=<contentHash>.json`

### 3.3 このキー設計の効能（事実）

- source_id ごとに履歴がまとまり、探索が容易
- hash 単位で immutable（同一内容は同一hash）にできる
- staging は常に「最新の s3_key」を保持できる

## 4. 保存判定（差分判定）

### 4.1 判定の真実（確定）

- 差分判定の真実は apl.staging.content_hash
- 判定対象は normalizedデータのhash

### 4.2 保存条件（確定）

apl.staging に同一 (source, entity, source_id, content_hash) が存在しない場合のみ S3 put。

**一致する場合**

- S3 putしない
- stagingも更新しない（MVP方針）

## 5. 保存するJSONの中身（重要：どちらにするかを固定）

MVPとして推奨は **「normalizedのみ保存」**。

### 5.1 推奨：normalizedのみ保存

**保存内容**

- normalize(entity, raw) の戻り値（正規化済みJSON）

**メリット（事実/推論）**

- hashの対象と保存物が一致し、差分解析が簡単
- “揺れるメタ情報”が除外されるため履歴が汚れない
- 後で再処理しても同一hashになりやすい

**デメリット**

- 「APIが返した生の形」を完全には残さない

### 5.2 代替：raw + normalized を同梱

「監査・調査で生データが欲しい」ならこちら。

**例（同一オブジェクト内）**

```json
{
  "meta": {
    "source": "rakuten",
    "entity": "item",
    "source_id": "xxx",
    "fetched_at": "2026-01-27T13:00:00+09:00"
  },
  "raw": { "...": "APIレスポンス" },
  "normalized": { "...": "正規化後" }
}
```

**注意**

- hashは normalized のみから作る（rawを含めると揺れる）
- 現在の思想（hash差分・再実行耐性優先）だと、5.1が一番ブレない

## 6. staging との整合（参照の正）

### 6.1 staging が持つ情報（事実）

- s3_key：最新raw参照
- content_hash：最新hash
- saved_at：保存時刻
- etag：取得できた場合

### 6.2 参照関係（確定）

- 最新参照：apl.staging.s3_key → S3 object
- 履歴参照：S3 prefix（.../source_id=<id>/）で過去hash一覧を辿る

## 7. 例外・障害時の扱い（C-3整合）

### 7.1 重要原則（確定）

- S3 put 成功後にのみ staging を upsert
- S3 put が失敗した対象は DB を更新しない（再実行で回復）

### 7.2 “二重put”の考え方

- 同一hashのキーは同じ（理論上冪等）
- ただし put回数が増える可能性はあるため、基本は staging で抑制する

## 8. ライフサイクル（削除ポリシー）

### 8.1 MVP方針（確定）

- 削除しない（immutable履歴）
- ライフサイクルルール（Glacier移行等）は将来の費用次第で検討

### 8.2 将来検討（推論）

- 30日でIA、180日でGlacierなど
- entity別で保持期間差を付ける（rankingは短め等）

## 9. セキュリティ（最低限）

- バケットは env ごとに分離
- 書き込み権限は ETL実行ロールに限定
- 公開アクセス禁止（Block Public Access）

## 10. D-2 Done（受け入れ条件）

- env分離バケットが前提として明文化されている
- key設計（案A）が固定されている
- 保存判定が staging hash に基づくことが固定されている
- 保存物の形式（normalized推奨）が固定されている
- staging→S3参照の「正」が明文化されている

