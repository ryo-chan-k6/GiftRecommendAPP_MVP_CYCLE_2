# 共通アーキテクチャ図＋データフロー図

## 共通アーキテクチャ図

```mermaid
flowchart LR
  %% ========== Entry ==========
  subgraph Entry["起点（実行）"]
    GH["GitHub Actions (schedule / workflow_dispatch)"]
    CLI["CLI (python -m jobs.xxx)"]
  end

  %% ========== Handler / Orchestration ==========
  subgraph App["Batch App（Python）"]
    H["handler<br/>(引数解釈 / ログ / exit code)"]
    SVC["etl_service<br/>(フロー制御 / 冪等性の中心)"]
    POL["policy<br/>(対象集合の決定: 当日処理対象)"]
  end

  %% ========== External ==========
  subgraph Ext["外部"]
    RAK["Rakuten API<br/>(Ranking / Item / Genre / Tag / Shop)"]
    S3["S3 Raw Bucket<br/>(raw immutable)"]
  end

  %% ========== DB ==========
  subgraph DB["PostgreSQL (Supabase)"]
    STG["apl.staging<br/>(latest ledger)<br/>unique:(source, entity, source_id)"]
    APL["apl schema<br/>(item / item_tag / genre / tag / tag_group / shop / item_rank_snapshot)"]
  end

  %% ========== Components ==========
  subgraph Lib["共通部品（モジュール）"]
    RC["rakuten_client<br/>(API呼び出し/レート制御)"]
    HS["hasher<br/>(正規化→hash)"]
    RS["raw_store<br/>(S3 put/get)<br/>key=.../source_id=.../hash=..."]
    SR["staging_repo<br/>(select_not_exists_hash / batch_upsert)"]
    AR["apl_repos<br/>(upsert item/genre/tag/shop,<br/>upsert item_tag,<br/>update is_active,<br/>upsert snapshot)"]
  end

  %% ========== Wiring ==========
  GH --> H
  CLI --> H
  H --> SVC
  SVC --> POL

  SVC --> RC
  RC --> RAK

  SVC --> HS
  SVC --> SR
  SR --> STG

  SVC --> RS
  RS --> S3

  SVC --> AR
  AR --> APL

  %% data dependencies
  HS --> SR
  HS --> RS
  SR --> AR
  RS --> SR

```

## データフロー図

### 2.1 共通ETLフロー（raw差分→staging→apl）

「楽天APIレスポンス → 正規化 → hash → staging参照 → 未保存のみS3保存 → staging更新 → apl反映」
の共通骨格です（JOB-R/I/G/T で共通）。



```mermaid
sequenceDiagram
  autonumber
  actor Trigger as Trigger(GHA/CLI)
  participant Handler as handler
  participant Svc as etl_service
  participant Pol as policy(対象集合)
  participant Rc as rakuten_client
  participant Hash as hasher
  participant Stg as staging_repo
  participant S3 as raw_store(S3)
  participant Apl as apl_repos(DB)

  Trigger->>Handler: start(job_id, args)
  Handler->>Svc: run(job_id, args)

  Svc->>Pol: build_targets(job_id)
  Pol-->>Svc: targets(source_id[])

  loop for each target
    Svc->>Rc: fetch(entity, source_id)
    Rc-->>Svc: raw_json

    Svc->>Hash: normalize(raw_json) + hash()
    Hash-->>Svc: normalized + content_hash

    Svc->>Stg: select_not_exists_hash(source, entity, source_id, content_hash)
    alt hash already exists (no change)
      Stg-->>Svc: exists=true
      Svc-->>Svc: skip S3 put
    else new hash (changed)
      Stg-->>Svc: exists=false
      Svc->>S3: put_json(key=.../source_id=.../hash=... , normalized/raw)
      S3-->>Svc: etag, saved_at
    end

  Svc->>Stg: batch_upsert(latest ledger:<br/>content_hash, s3_key, etag, saved_at)
    Stg-->>Svc: upserted

    Svc->>Apl: upsert_to_apl(job_id, normalized)
    Apl-->>Svc: upserted
  end

  Svc-->>Handler: result(summary)
  Handler-->>Trigger: exit code + logs

```

### 2.2 ジョブネット（確定フロー）

ジョブネットを、実行順の依存として表現する。

```mermaid
flowchart TD
  R["JOB-R-01 Ranking ETL<br/>raw→staging→apl.item_rank_snapshot"] --> I["JOB-I-01 Item ETL<br/>raw→staging→apl.item & apl.item_tag"]
  I --> G["JOB-G-01 Genre ETL<br/>raw→staging→apl.genre"]
  I --> T["JOB-T-01 Tag ETL<br/>raw→staging→apl.tag_group & apl.tag"]
  G --> A["JOB-A-01 is_active 更新<br/>apl.item.is_active 確定"]
  T --> A
  A --> END((END))

  %% parallel note
  classDef p fill:#fff,stroke:#999,stroke-dasharray: 5 5;
  class G,T p;

```

### 2.3 is_active 更新フロー（最後に必ず実行）

「genre と shop が存在する」→ true、そうでない→ false。
IS DISTINCT FROM で無駄更新を抑制し、updated_at = now() を明示。

```mermaid
sequenceDiagram
  autonumber
  participant Svc as etl_service(JOB-A-01)
  participant DB as PostgreSQL(apl)

  Svc->>DB: BEGIN
  Svc->>DB: UPDATE apl.item i<br/>SET is_active = CASE WHEN EXISTS(genre) AND EXISTS(shop) THEN true ELSE false END,<br/>    updated_at = now()<br/>WHERE i.is_active IS DISTINCT FROM <computed>;
  DB-->>Svc: updated_rows
  Svc->>DB: COMMIT

```
